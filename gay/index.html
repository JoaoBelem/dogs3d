<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mundo 3D - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        /* Sobreposição de instruções */
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #instructions {
            text-align: center;
            color: white;
            cursor: pointer;
        }

        #instructions h1 {
            font-size: 36px;
        }

        #instructions p {
            font-size: 18px;
        }
    </style>
</head>

<body>

    <div id="blocker">
        <div id="instructions">
            <h1>Clique para Jogar</h1>
            <p>
                Mova-se: W, A, S, D<br>
                Pule: Espaço<br>
                Olhe: Mouse
            </p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let camera, scene, renderer, controls, texturedCube, snowParticles, snowCount, obstacles;

        // Variáveis de movimento
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        init();
        animate();

        function init() {
            // 1. Configuração da Cena e Câmera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Cor do Céu (Sky Blue)
            scene.fog = new THREE.Fog(0x87CEEB, 0, 750); // Neblina para suavizar o horizonte

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 10; // Altura dos olhos do personagem

            // 2. Iluminação
            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1); // Sol
            dirLight.position.set(50, 200, 100);
            scene.add(dirLight);

            // 3. Controles (PointerLock)
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

            scene.add(controls.getObject());

            // 4. Listeners de Teclado (WASD)
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump === true) velocity.y += 150;
                        canJump = false;
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 5. O Mundo (Chão e Paredes)

            // Chão
            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);

            // Textura simples usando cores de vértice para dar um efeito xadrez sutil
            const position = floorGeometry.attributes.position;
            const vertex = new THREE.Vector3();
            const color = new THREE.Color();
            const colors = [];

            for (let i = 0, l = position.count; i < l; i++) {
                vertex.fromBufferAttribute(position, i);
                // Cria variações de verde
                color.setHSL(Math.random() * 0.3 + 0.2, 0.75, Math.random() * 0.25 + 0.5);
                colors.push(color.r, color.g, color.b);
            }
            floorGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const floorMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            scene.add(floor);

            // Paredes (Criação de cubos simples)
            const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
            const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444, flatShading: true });

            // Gerar algumas paredes aleatórias
            obstacles = [];
            for (let i = 0; i < 20; i++) {
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.x = Math.floor(Math.random() * 20 - 10) * 20;
                box.position.y = 10; // Metade da altura para ficar no chão
                box.position.z = Math.floor(Math.random() * 20 - 10) * 20;
                scene.add(box);
                const boxBB = new THREE.Box3().setFromObject(box);
                obstacles.push({ mesh: box, box: boxBB });
            }

            // Cubo texturizado (mesma textura em todas as faces)
            // Deixe `textureURL` vazio para você inserir o link da imagem
            const textureURL = './estud.jpg'; // <-- coloque o link da imagem aqui
            const loader = new THREE.TextureLoader();
            const texture = loader.load(
                textureURL,
                undefined,
                undefined,
                function () { console.warn('Falha ao carregar a textura:', textureURL); }
            );

            const cubeMaterials = [];
            for (let i = 0; i < 6; i++) {
                cubeMaterials.push(new THREE.MeshPhongMaterial({ map: texture }));
            }

            const cubeGeometry = new THREE.BoxGeometry(20, 20, 20);
            texturedCube = new THREE.Mesh(cubeGeometry, cubeMaterials);
            texturedCube.position.set(0, 10, -50);
            scene.add(texturedCube);
            // Adiciona cubo texturizado como obstáculo físico
            const cubeBB = new THREE.Box3().setFromObject(texturedCube);
            obstacles.push({ mesh: texturedCube, box: cubeBB });

            // Partículas de neve (flocos caindo)
            snowCount = 500;
            const snowGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(snowCount * 3);
            const velocities = new Float32Array(snowCount);

            for (let i = 0; i < snowCount; i++) {
                positions[3 * i] = Math.random() * 2000 - 1000; // x
                positions[3 * i + 1] = Math.random() * 800 + 50; // y (altura inicial)
                positions[3 * i + 2] = Math.random() * 2000 - 1000; // z
                velocities[i] = Math.random() * 0.6 + 0.1; // velocidade individual
            }

            snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

            // Gera uma textura circular simples para os flocos (canvas)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 2, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.9)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const sprite = new THREE.CanvasTexture(canvas);

            const snowMaterial = new THREE.PointsMaterial({
                size: 8,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);

            // 6. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);


            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked === true) {

                // Resistência (Fricção) - o personagem para se soltar a tecla
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 50.0 * delta; // Gravidade (mass = 100.0)

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Garante movimento consistente em diagonais

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                // Aplica movimento lateral (Strafe) e frontal
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Aplica movimento vertical (Pulo/Gravidade)
                controls.getObject().position.y += (velocity.y * delta);

                // Detecção simples de colisão com o chão
                if (controls.getObject().position.y < 10) {
                    velocity.y = 0;
                    controls.getObject().position.y = 10;
                    canJump = true;
                }
            }

            // Rotação lenta do cubo (se existir)
            if (texturedCube) {
                texturedCube.rotation.y += 0.3 * delta;
            }

                // Atualiza partículas de neve
                if (snowParticles) {
                    const pos = snowParticles.geometry.attributes.position.array;
                    const vel = snowParticles.geometry.attributes.velocity.array;
                    for (let i = 0; i < snowCount; i++) {
                        const idx = 3 * i;
                        // cai baseado na velocidade individual
                        pos[idx + 1] -= vel[i] * 60.0 * delta;
                        // leve deriva lateral
                        pos[idx] += Math.sin((time / 1000) + i) * 0.2 * delta * 10;
                        pos[idx + 2] += Math.cos((time / 1000) + i * 0.7) * 0.1 * delta * 10;

                        // quando abaixo do chão, reinicia acima
                        if (pos[idx + 1] < 0) {
                            pos[idx + 1] = Math.random() * 800 + 400;
                            pos[idx] = Math.random() * 2000 - 1000;
                            pos[idx + 2] = Math.random() * 2000 - 1000;
                        }
                    }
                    snowParticles.geometry.attributes.position.needsUpdate = true;
                }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>